import React, { createContext, useContext, useEffect, useState } from 'react';
import { supabase } from '../lib/supabaseClient';
import { createClient as createSupabaseClient, SupabaseClient } from '@supabase/supabase-js';

type UserRole = 'admin' | 'diretoria' | 'solicitante' | 'portaria';

export interface User {
  id: string;
  email: string;
  name: string;
  role: UserRole;
}

interface UserRecord {
  password?: string;
  user: User;
}

interface AuthContextType {
  user: User | null;
  login: (email: string, password: string) => Promise<boolean>;
  logout: () => Promise<void>;
  isAuthenticated: boolean;
  users: UserRecord[];
  addUser: (name: string, email: string, password: string, role: UserRole) => Promise<void>;
  updateUser: (id: string, name: string, email: string, role: UserRole) => Promise<void>;
  deleteUser: (identifier: string) => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [users, setUsers] = useState<UserRecord[]>([]);

  useEffect(() => {
    // restore session
    (async () => {
      try {
        const { data } = await supabase.auth.getSession();
        const sessionUser = data?.session?.user;
        if (sessionUser?.id) {
          const { data: profile } = await supabase.from('profiles').select('*').eq('id', sessionUser.id).single();
          if (profile) {
            setUser({ id: profile.id, email: profile.email, name: profile.full_name || profile.email, role: profile.role });
          }
        }
      } catch (err) {
        console.warn('Erro restaurando sessão', err);
      }
    })();

    // load profiles list
    (async () => {
      try {
        const { data } = await supabase.from('profiles').select('*');
        if (data) {
          type ProfileRow = { id: string; email: string; full_name?: string; role?: string };
          const mapped: UserRecord[] = (data as ProfileRow[]).map((p) => ({ password: '', user: { id: p.id, email: p.email, name: p.full_name || p.email, role: (p.role as UserRole) || 'solicitante' } }));
          setUsers(mapped);
        }
      } catch (err) {
        console.warn('Erro carregando profiles', err);
      }
    })();
  }, []);

  const login = async (email: string, password: string): Promise<boolean> => {
    try {
      const res = await supabase.auth.signInWithPassword({ email, password });
      if (res.error) {
        console.warn('login error', res.error);
        return false;
      }
      const authUser = res.data?.user || res.data?.session?.user;
      if (!authUser) return false;
      const { data: profile } = await supabase.from('profiles').select('*').eq('email', email).single();
      if (profile) {
        setUser({ id: profile.id, email: profile.email, name: profile.full_name || profile.email, role: profile.role });
      } else {
        setUser({ id: authUser.id, email: authUser.email || email, name: (authUser as any).user_metadata?.full_name || authUser.email || 'Usuário', role: 'solicitante' });
      }
      return true;
    } catch (err) {
      console.warn('Erro login', err);
      return false;
    }
  };

  const logout = async () => {
    try {
      await supabase.auth.signOut();
    } catch (err) {
      console.warn('Erro signOut', err);
    }
    setUser(null);
  };

  const addUser = async (name: string, email: string, password: string, role: UserRole) => {
    try {
      const SERVICE_ROLE = import.meta.env.VITE_SUPABASE_SERVICE_ROLE_KEY as string | undefined;
      const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL as string;
      let createdId: string | null = null;

      if (SERVICE_ROLE) {
        try {
          const admin: SupabaseClient = createSupabaseClient(SUPABASE_URL, SERVICE_ROLE, { auth: { persistSession: false } });

          console.log('Creating user via admin.createUser', { email, role });
          // admin.auth.admin.createUser typing varies by SDK, use unknown and narrow
          const adminAuth: unknown = (admin.auth as unknown);
          // Call createUser via admin client using index access to avoid any
          const createResult = await (adminAuth as any).admin.createUser({ email, password, email_confirm: true });
          const createData = createResult?.data ?? createResult;
          const createError = createResult?.error ?? createResult?.error;

          console.log('admin.createUser response', { createData, createError });

          if (createError) {
            console.error('admin.createUser error', createError);
            throw createError;
          }

          // Normalize user id
          const createdUser = (createData && (createData.user || createData)) || null;
          createdId = createdUser?.id || null;

          if (!createdId) {
            console.warn('Could not determine created user id from admin.createUser response', createData);
            throw new Error('No user id returned from admin.createUser');
          }

          // Upsert profile using admin client to ensure permissions
          type ProfilePayload = { id: string; email: string; full_name: string; role: UserRole };
          const { error: profileError } = await admin.from('profiles').upsert({ id: createdId, email, full_name: name, role } as ProfilePayload);
          if (profileError) {
            console.error('admin upsert profile error', profileError);
            throw profileError;
          }

          console.log(`✅ Usuário ${email} criado como ${role} (id=${createdId})`);
        } catch (err) {
          console.error('Erro criando usuário via admin SDK/API', err);
          alert('Falha ao criar usuário via Admin API/SDK. Verifique console e considere usar o script server-side.');
        }
      } else {
        // client signUp
        const { data, error } = await supabase.auth.signUp({ email, password });
        if (error) console.warn('signUp error', error);
        if (data?.user) createdId = data.user.id;
      }

      // ensure profiles table has entry (fallback)
      if (!createdId) {
        // try to find profile by email
        const { data: existing } = await supabase.from('profiles').select('id').eq('email', email).single();
        type ExistingProfile = { id?: string };
        if (existing && (existing as ExistingProfile).id) createdId = (existing as ExistingProfile).id as string;
      }

      type ProfilePayloadFallback = { id?: string; email: string; full_name: string; role: UserRole };
      const payload: ProfilePayloadFallback = { email, full_name: name, role };
      if (createdId) payload.id = createdId;
      const { data: upserted, error: upsertErr } = await supabase.from('profiles').upsert(payload).select();
      if (upsertErr) {
        console.warn('profiles upsert error', upsertErr);
      } else {
        const prof = upserted && upserted[0] ? upserted[0] : null;
        const rec: UserRecord = { password, user: { id: prof?.id || createdId || '', email, name: prof?.full_name || name, role } };
        setUsers((s) => [...s, rec]);
      }
    } catch (err) {
      console.warn('addUser error', err);
    }
  };

  const updateUser = async (id: string, name: string, email: string, role: UserRole) => {
    try {
      const { error } = await supabase.from('profiles').update({ full_name: name, email, role }).eq('id', id);
      if (error) console.warn('update profile error', error);
      setUsers((prev) => prev.map((u) => (u.user.id === id ? { ...u, user: { id, email, name, role } } : u)));
      // if updating currently logged user, update local user
      if (user?.id === id) setUser({ id, email, name, role });
    } catch (err) {
      console.warn('updateUser error', err);
    }
  };

  const deleteUser = async (identifier: string) => {
    try {
      const SERVICE_ROLE = import.meta.env.VITE_SUPABASE_SERVICE_ROLE_KEY as string | undefined;
      // resolve id
      let targetId: string | null = null;
      if (identifier.includes('@')) {
        const { data: profile } = await supabase.from('profiles').select('id').eq('email', identifier).single();
        type ExistingProfile = { id?: string };
        if (profile && (profile as ExistingProfile).id) targetId = (profile as ExistingProfile).id as string;
      } else {
        targetId = identifier;
      }
      if (!targetId) {
        console.warn('deleteUser: id not resolved');
        return;
      }
      if (SERVICE_ROLE) {
        try {
          const admin = createSupabaseClient(import.meta.env.VITE_SUPABASE_URL as string, SERVICE_ROLE, { auth: { persistSession: false } });
          const adminAuth: unknown = (admin.auth as unknown);
          // Try known admin delete functions then fallback to REST
          if ((adminAuth as any)?.admin && typeof (adminAuth as any).admin.deleteUserById === 'function') {
            await (adminAuth as any).admin.deleteUserById(targetId);
          } else if ((adminAuth as any)?.admin && typeof (adminAuth as any).admin.deleteUser === 'function') {
            await (adminAuth as any).admin.deleteUser(targetId);
          } else {
            const resp = await fetch(`${import.meta.env.VITE_SUPABASE_URL}/auth/v1/admin/users/${targetId}`, {
              method: 'DELETE',
              headers: { apikey: SERVICE_ROLE, Authorization: `Bearer ${SERVICE_ROLE}` },
            });
            if (!resp.ok) {
              const text = await resp.text();
              console.warn('admin delete failed', resp.status, text);
            }
          }
        } catch (err) {
          console.warn('admin delete error', err);
        }
      } else {
        console.warn('Service role not provided; auth user may not be deleted');
      }
      const { error } = await supabase.from('profiles').delete().eq('id', targetId);
      if (error) console.warn('delete profile error', error);
      setUsers((prev) => prev.filter((u) => u.user.id !== targetId));
      if (user?.id === targetId) setUser(null);
    } catch (err) {
      console.warn('deleteUser error', err);
    }
  };

  const value: AuthContextType = {
    user,
    login,
    logout,
    isAuthenticated: !!user,
    users,
    addUser,
    updateUser,
    deleteUser,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export const useAuth = () => {
  const ctx = useContext(AuthContext);
  if (!ctx) throw new Error('useAuth must be used within AuthProvider');
  return ctx;
};
