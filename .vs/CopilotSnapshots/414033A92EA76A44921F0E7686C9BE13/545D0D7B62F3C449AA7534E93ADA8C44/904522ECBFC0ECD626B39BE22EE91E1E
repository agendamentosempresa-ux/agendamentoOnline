import React, { createContext, useContext, useEffect, useState } from 'react';
import { supabase } from '../lib/supabaseClient';
import { createClient as createSupabaseClient } from '@supabase/supabase-js';

type UserRole = 'admin' | 'diretoria' | 'solicitante' | 'portaria';

export interface User {
  id: string;
  email: string;
  name: string;
  role: UserRole;
}

interface UserRecord {
  password?: string;
  user: User;
}

interface AuthContextType {
  user: User | null;
  login: (email: string, password: string) => Promise<boolean>;
  logout: () => Promise<void>;
  isAuthenticated: boolean;
  users: UserRecord[];
  addUser: (name: string, email: string, password: string, role: UserRole) => Promise<void>;
  updateUser: (id: string, name: string, email: string, role: UserRole) => Promise<void>;
  deleteUser: (identifier: string) => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [users, setUsers] = useState<UserRecord[]>([]);

  useEffect(() => {
    // restore session
    (async () => {
      try {
        const { data } = await supabase.auth.getSession();
        const sessionUser = data?.session?.user;
        if (sessionUser?.id) {
          const { data: profile } = await supabase.from('profiles').select('*').eq('id', sessionUser.id).single();
          if (profile) {
            setUser({ id: profile.id, email: profile.email, name: profile.full_name || profile.email, role: profile.role });
          }
        }
      } catch (err) {
        console.warn('Erro restaurando sessão', err);
      }
    })();

    // load profiles list
    (async () => {
      try {
        const { data } = await supabase.from('profiles').select('*');
        if (data) {
          const mapped: UserRecord[] = (data as any[]).map((p) => ({ password: '', user: { id: p.id, email: p.email, name: p.full_name || p.email, role: (p.role as UserRole) || 'solicitante' } }));
          setUsers(mapped);
        }
      } catch (err) {
        console.warn('Erro carregando profiles', err);
      }
    })();
  }, []);

  const login = async (email: string, password: string): Promise<boolean> => {
    try {
      const res = await supabase.auth.signInWithPassword({ email, password });
      if (res.error) {
        console.warn('login error', res.error);
        return false;
      }
      const authUser = res.data?.user || res.data?.session?.user;
      if (!authUser) return false;
      const { data: profile } = await supabase.from('profiles').select('*').eq('email', email).single();
      if (profile) {
        setUser({ id: profile.id, email: profile.email, name: profile.full_name || profile.email, role: profile.role });
      } else {
        setUser({ id: authUser.id, email: authUser.email || email, name: authUser.user_metadata?.full_name || authUser.email || 'Usuário', role: 'solicitante' });
      }
      return true;
    } catch (err) {
      console.warn('Erro login', err);
      return false;
    }
  };

  const logout = async () => {
    try {
      await supabase.auth.signOut();
    } catch (err) {
      console.warn('Erro signOut', err);
    }
    setUser(null);
  };

  const addUser = async (name: string, email: string, password: string, role: UserRole) => {
    try {
      const SERVICE_ROLE = import.meta.env.VITE_SUPABASE_SERVICE_ROLE_KEY as string | undefined;
      const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL as string;
      let createdId: string | null = null;

      if (SERVICE_ROLE) {
        // Use Supabase admin SDK (createClient with service role) to create user server-side ideally
        try {
          const admin = createSupabaseClient(SUPABASE_URL, SERVICE_ROLE, { auth: { persistSession: false } });
          const { data, error } = await admin.auth.admin.createUser({
            email,
            password,
            email_confirm: true,
          } as any);

          if (error) {
            console.error('admin.createUser error', error);
          } else if (data) {
            // data may be { user: {...} } or user object depending on SDK version
            const userObj = (data as any).user || data;
            createdId = userObj?.id || null;
            if (!createdId) console.warn('admin.createUser returned no id', data);
          }

          // upsert profile with admin client to ensure permission
          if (createdId) {
            const { error: upsertErr } = await admin.from('profiles').upsert({ id: createdId, email, full_name: name, role } as any);
            if (upsertErr) console.error('admin upsert profile error', upsertErr);
          }
        } catch (err) {
          console.error('Erro criando usuário via admin SDK', err);
        }
      } else {
        // client signUp
        const { data, error } = await supabase.auth.signUp({ email, password });
        if (error) console.warn('signUp error', error);
        if (data?.user) createdId = data.user.id;
      }

      // ensure profiles table has entry
      const payload: any = { email, full_name: name, role };
      if (createdId) payload.id = createdId;
      const { data: upserted, error: upsertErr } = await supabase.from('profiles').upsert(payload).select();
      if (upsertErr) {
        console.warn('profiles upsert error', upsertErr);
      } else {
        const prof = upserted && upserted[0] ? upserted[0] : null;
        const rec: UserRecord = { password, user: { id: prof?.id || createdId || '', email, name: prof?.full_name || name, role } };
        setUsers((s) => [...s, rec]);
      }
    } catch (err) {
      console.warn('addUser error', err);
    }
  };

  const updateUser = async (id: string, name: string, email: string, role: UserRole) => {
    try {
      const { error } = await supabase.from('profiles').update({ full_name: name, email, role }).eq('id', id);
      if (error) console.warn('update profile error', error);
      setUsers((prev) => prev.map((u) => (u.user.id === id ? { ...u, user: { id, email, name, role } } : u)));
      // if updating currently logged user, update local user
      if (user?.id === id) setUser({ id, email, name, role });
    } catch (err) {
      console.warn('updateUser error', err);
    }
  };

  const deleteUser = async (identifier: string) => {
    try {
      const SERVICE_ROLE = import.meta.env.VITE_SUPABASE_SERVICE_ROLE_KEY as string | undefined;
      // resolve id
      let targetId: string | null = null;
      if (identifier.includes('@')) {
        const { data: profile } = await supabase.from('profiles').select('id').eq('email', identifier).single();
        if (profile && (profile as any).id) targetId = (profile as any).id;
      } else {
        targetId = identifier;
      }
      if (!targetId) {
        console.warn('deleteUser: id not resolved');
        return;
      }
      if (SERVICE_ROLE) {
        try {
          const admin = createSupabaseClient(import.meta.env.VITE_SUPABASE_URL as string, SERVICE_ROLE, { auth: { persistSession: false } });
          // supabase-js admin delete method may be available; fallback to admin REST if needed
          if (admin.auth && (admin.auth as any).admin && typeof (admin.auth as any).admin.deleteUserById === 'function') {
            await (admin.auth as any).admin.deleteUserById(targetId);
          } else if (admin.auth && (admin.auth as any).admin && typeof (admin.auth as any).admin.deleteUser === 'function') {
            await (admin.auth as any).admin.deleteUser(targetId);
          } else {
            // fallback to REST
            const resp = await fetch(`${import.meta.env.VITE_SUPABASE_URL}/auth/v1/admin/users/${targetId}`, {
              method: 'DELETE',
              headers: { apikey: SERVICE_ROLE, Authorization: `Bearer ${SERVICE_ROLE}` },
            });
            if (!resp.ok) {
              const text = await resp.text();
              console.warn('admin delete failed', resp.status, text);
            }
          }
        } catch (err) {
          console.warn('admin delete error', err);
        }
      } else {
        console.warn('Service role not provided; auth user may not be deleted');
      }
      const { error } = await supabase.from('profiles').delete().eq('id', targetId);
      if (error) console.warn('delete profile error', error);
      setUsers((prev) => prev.filter((u) => u.user.id !== targetId));
      if (user?.id === targetId) setUser(null);
    } catch (err) {
      console.warn('deleteUser error', err);
    }
  };

  const value: AuthContextType = {
    user,
    login,
    logout,
    isAuthenticated: !!user,
    users,
    addUser,
    updateUser,
    deleteUser,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export const useAuth = () => {
  const ctx = useContext(AuthContext);
  if (!ctx) throw new Error('useAuth must be used within AuthProvider');
  return ctx;
};
