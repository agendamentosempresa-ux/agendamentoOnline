import React, { createContext, useContext, useEffect, useState } from 'react';
import { supabase } from '../lib/supabaseClient';

type UserRole = 'admin' | 'diretoria' | 'solicitante' | 'portaria';

export interface User {
  id: string;
  email: string;
  name: string;
  role: UserRole;
}

interface UserRecord {
  password?: string;
  user: User;
}

interface AuthContextType {
  user: User | null;
  login: (email: string, password: string) => Promise<boolean>;
  logout: () => Promise<void>;
  isAuthenticated: boolean;
  users: UserRecord[];
  addUser: (name: string, email: string, password: string, role: UserRole) => Promise<void>;
  updateUser: (id: string, name: string, email: string, role: UserRole) => Promise<void>;
  deleteUser: (identifier: string) => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [users, setUsers] = useState<UserRecord[]>([]);

  useEffect(() => {
    // restore session
    (async () => {
      try {
        const { data } = await supabase.auth.getSession();
        const sessionUser = data?.session?.user;
        if (sessionUser?.id) {
          const { data: profile } = await supabase.from('profiles').select('*').eq('id', sessionUser.id).single();
          if (profile) {
            setUser({ id: profile.id, email: profile.email, name: profile.full_name || profile.email, role: profile.role });
          }
        }
      } catch (err) {
        console.warn('Erro restaurando sessão', err);
      }
    })();

    // load profiles list
    (async () => {
      try {
        const { data } = await supabase.from('profiles').select('*');
        if (data) {
          const mapped: UserRecord[] = (data as any[]).map((p) => ({ password: '', user: { id: p.id, email: p.email, name: p.full_name || p.email, role: (p.role as UserRole) || 'solicitante' } }));
          setUsers(mapped);
        }
      } catch (err) {
        console.warn('Erro carregando profiles', err);
      }
    })();
  }, []);

  const login = async (email: string, password: string): Promise<boolean> => {
    try {
      const res = await supabase.auth.signInWithPassword({ email, password });
      if (res.error) {
        console.warn('login error', res.error);
        return false;
      }
      const authUser = res.data?.user || res.data?.session?.user;
      if (!authUser) return false;
      const { data: profile } = await supabase.from('profiles').select('*').eq('email', email).single();
      if (profile) {
        setUser({ id: profile.id, email: profile.email, name: profile.full_name || profile.email, role: profile.role });
      } else {
        setUser({ id: authUser.id, email: authUser.email || email, name: authUser.user_metadata?.full_name || authUser.email || 'Usuário', role: 'solicitante' });
      }
      return true;
    } catch (err) {
      console.warn('Erro login', err);
      return false;
    }
  };

  const logout = async () => {
    try {
      await supabase.auth.signOut();
    } catch (err) {
      console.warn('Erro signOut', err);
    }
    setUser(null);
  };

  const addUser = async (name: string, email: string, password: string, role: UserRole) => {
    try {
      const SERVICE_ROLE = import.meta.env.VITE_SUPABASE_SERVICE_ROLE_KEY as string | undefined;
      const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL as string;
      let createdId: string | null = null;

      if (SERVICE_ROLE) {
        // Call admin REST API server-side recommended; calling from client may be blocked by CORS. Still attempt and report response.
        const resp = await fetch(`${SUPABASE_URL}/auth/v1/admin/users`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            apikey: SERVICE_ROLE,
            Authorization: `Bearer ${SERVICE_ROLE}`,
          },
          body: JSON.stringify({ email, password, email_confirm: true }),
        });
        const text = await resp.text();
        let json: any = null;
        try { json = text ? JSON.parse(text) : null; } catch { json = null; }
        if (!resp.ok) {
          console.error('admin create user failed', resp.status, text);
        } else {
          createdId = json?.id || json?.user?.id || null;
        }
      } else {
        // client signUp
        const { data, error } = await supabase.auth.signUp({ email, password });
        if (error) console.warn('signUp error', error);
        if (data?.user) createdId = data.user.id;
      }

      const payload: any = { email, full_name: name, role };
      if (createdId) payload.id = createdId;
      const { data: upserted, error: upsertErr } = await supabase.from('profiles').upsert(payload).select();
      if (upsertErr) {
        console.warn('profiles upsert error', upsertErr);
      } else {
        const prof = upserted && upserted[0] ? upserted[0] : null;
        const rec: UserRecord = { password, user: { id: prof?.id || createdId || '', email, name: prof?.full_name || name, role } };
        setUsers((s) => [...s, rec]);
      }
    } catch (err) {
      console.warn('addUser error', err);
    }
  };

  const updateUser = async (id: string, name: string, email: string, role: UserRole) => {
    try {
      const { error } = await supabase.from('profiles').update({ full_name: name, email, role }).eq('id', id);
      if (error) console.warn('update profile error', error);
      setUsers((prev) => prev.map((u) => (u.user.id === id ? { ...u, user: { id, email, name, role } } : u)));
      // if updating currently logged user, update local user
      if (user?.id === id) setUser({ id, email, name, role });
    } catch (err) {
      console.warn('updateUser error', err);
    }
  };

  const deleteUser = async (identifier: string) => {
    try {
      const SERVICE_ROLE = import.meta.env.VITE_SUPABASE_SERVICE_ROLE_KEY as string | undefined;
      // resolve id
      let targetId: string | null = null;
      if (identifier.includes('@')) {
        const { data: profile } = await supabase.from('profiles').select('id').eq('email', identifier).single();
        if (profile && (profile as any).id) targetId

export const useAuth = () => {
  const ctx = useContext(AuthContext);
  if (!ctx) throw new Error('useAuth must be used within AuthProvider');
  return ctx;
};
